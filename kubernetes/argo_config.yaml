resources: # List of K8s resources to list, watch, and export to Port.
  - kind: v1/namespaces # group/version/resource (G/V/R) format
    selector:
      query: .metadata.name | startswith("kube") | not # JQ boolean query. If evaluated to false - skip syncing the object.
    port:
      entity:
        mappings: # Mappings between one K8s object to one or many Port Entities. Each value is a JQ query.
          - identifier: .metadata.name + "-" + "{CLUSTER_NAME}"
            title: .metadata.name
            blueprint: '"namespace"'
            properties:
              creationTimestamp: .metadata.creationTimestamp
              labels: .metadata.labels
            relations:
              Cluster: '"{CLUSTER_NAME}"'


# Defines cluster using the uniq 
  - kind: v1/namespaces
    selector:
      query: .metadata.name | contains("kube-system")
    port:
      entity:
        mappings:
          - identifier: '"{CLUSTER_NAME}"'
            title: '"{CLUSTER_NAME}"'
            blueprint: '"cluster"'

  - kind: apps/v1/deployments
    selector:
      query: .metadata.namespace | startswith("kube") | not
    port:
      entity:
        mappings:
          - identifier: .metadata.name + "-" + .metadata.namespace + "-" + "{CLUSTER_NAME}"
            title: .metadata.name
            icon: '"Deployment"'
            blueprint: '"deployment"'
            properties:
              creationTimestamp: .metadata.creationTimestamp
              replicas: .spec.replicas
              hasPrivileged: .spec.template.spec.containers | [.[].securityContext.privileged] | any
              hasLatest: .spec.template.spec.containers[].image | contains(":latest")
              hasLimits: .spec.template.spec.containers | all(has("resources") and (.resources.limits.memory and .resources.limits.cpu))
              strategy: .spec.strategy.type
              availableReplicas: .status.availableReplicas
              labels: .metadata.labels
              containers: (.spec.template.spec.containers | map({name, image, resources}))
            relations:
              Namespace: .metadata.namespace + "-" + "{CLUSTER_NAME}"

  - kind: argoproj.io/v1alpha1/applications
    port:
      entity:
        mappings:
          - identifier: .metadata.name + "-" + .metadata.namespace + "-" + "{CLUSTER_NAME}"
            blueprint: '"argocdApp"'
            title: .metadata.name
            properties:
              status: .status.health.status
              syncStatus: .status.sync.status
              syncPolicy: .spec.syncPolicy // null
              gitRepo: .spec.source.repoURL
              gitPath: .spec.source.path
              gitRev: .status.sync.revision // null
            relations:
              Deployment: .spec.destination.namespace as $namespace | .status.resources | map(select(.kind == "Deployment") | .name + "-" + $namespace + "-" + "{CLUSTER_NAME}")
              ArgoProject: .spec.project + "-" + .metadata.namespace + "-" + "{CLUSTER_NAME}"
              destinationNamespace: .spec.destination.namespace + "-" + "{CLUSTER_NAME}"

  - kind: argoproj.io/v1alpha1/appproject
    port:
      entity:
        mappings:
          - identifier: .metadata.name + "-" + .metadata.namespace + "-" + "{CLUSTER_NAME}"
            title: .metadata.name
            blueprint: '"argocdProject"'
            properties:
              name: .metadata.name
              title: .metadata.name
            relations:
              Namespace: .metadata.namespace + "-" + '"{CLUSTER_NAME}"'

  - kind: v1/secrets
    selector:
      query: '.metadata.labels // {} | contains({ "argocd.argoproj.io/secret-type": "repository" })'
    port:
      entity:
        mappings:
          - identifier: .metadata.name + "-" + .metadata.namespace + "-" + "{CLUSTER_NAME}"
            title: .metadata.name
            blueprint: '"argoRepo"'
            properties:
              repoUrl: .data.url | @base64d
              repoType: .data.type | @base64d
            relations:
              Namespace: .metadata.namespace + "-" + "{CLUSTER_NAME}"

 